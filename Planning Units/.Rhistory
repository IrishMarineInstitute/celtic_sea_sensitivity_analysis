# 3.2 Generate boundary length data for the planning units
# ---------------------------------
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
bld_1km <- boundary_matrix(pu_1km)
#bld_1km@x <- rescale(bld_1km@x, to = c(0.001,10)) # Deprecated in PrioritizR 8.0.2.7
bld_1km <-rescale_matrix(bld_1km, max = 10)  # Use for all versions after PrioritizR 8.0.2.7
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -4   # change this for your own data
prelim_upper <- 0  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_1km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_1km) %>%
add_neighbor_constraints(k=3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 600, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(prelim, file = paste0(scenario_name, "_prelim.RData"))
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
# define a new set of penalty values that ranges below the two preferred prelim values
# This time a linear scale is applied
penalty <- round(seq(prelim_penalty[6], prelim_penalty[7], length.out = 9), 5)
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
solution <- lapply(penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_1km) %>%
add_neighbor_constraints(k = 3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.1, time_limit = 1200, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.05, time_limit = 3600, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(solution, file = paste0(scenario_name, "_solution.RData"))
solutions <-stack(solution)
#double check working directory
png(paste0(scenario_name, "_solutions.png"), width = 1200, height = 1200, res = 300)
plot(solutions, axes = FALSE, box = FALSE)
dev.off()
plot(solutions, axes = FALSE, box = FALSE)
dev.off()
plot(solutions, axes = FALSE, box = FALSE)
dev.off()
plot(solutions, axes = FALSE, box = FALSE)
# ---------------------------------
# 3.2 Generate boundary length data for the planning units
# ---------------------------------
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
bld_1km <- boundary_matrix(pu_1km)
View(bld_1km)
View(bld_1km)
?rescale_matrix
?boundary_matrix
st_crs(pu_1km)
library(sf)
st_crs(pu_1km)
#bld_1km@x <- rescale(bld_1km@x, to = c(0.001,10)) # Deprecated in PrioritizR 8.0.2.7
bld_1km <-rescale_matrix(bld_1km, max = 10)  # Use for all versions after PrioritizR 8.0.2.7
# ---------------------------------
# 3.2 Generate boundary length data for the planning units
# ---------------------------------
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
bld_1km <- boundary_matrix(pu_1km)
#bld_1km@x <- rescale(bld_1km@x, to = c(0.001,10)) # Deprecated in PrioritizR 8.0.2.7
bld_1km <-rescale_matrix(bld_1km, max = 10)  # Use for all versions after PrioritizR 8.0.2.7
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -4   # change this for your own data
prelim_upper <- 0  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
name(cost)
cost
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_1km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_1km) %>%
add_neighbor_constraints(k=3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 1200, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -3   # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
prelim_upper <- -1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -2   # change this for your own data
prelim_upper <- -1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -1.5   # change this for your own data
prelim_upper <- -1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_1km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_1km) %>%
add_neighbor_constraints(k=3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 1200, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(prelim, file = paste0(scenario_name, "_prelim.RData"))
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
#Aggregation method averages values across aggregated cells
feat_stack_3km <-aggregate(feat_stack_1km, fact=3)
# Aggregation method sums values across aggregated cells to maintain total costs of layer
cost_stack_3km <-aggregate(cost_stack_1km, fact=3, fun = sum)
# Aggregation of pu layer to 3km
pu_3km <- aggregate(pu_1km, fact=3, fun = sum)
ORE_3km <- aggregate(ORE_1km, fact =3)
# ---------------------------------
# 3.0 Set up scenario and solve
# ---------------------------------
# CHANGE TO cost_stack_3km IF WORKING 3KM SCALE
cellno <- sum(!is.na(getValues(cost_stack_1km[[1]])))
cellno
# ---------------------------------
# 3.0 Set up scenario and solve
# ---------------------------------
# CHANGE TO cost_stack_3km IF WORKING 3KM SCALE
cellno <- sum(!is.na(getValues(cost_stack_3km[[1]])))
cellno
setwd("../")
setwd("../Solutions")
scenario_name <- "3km_TEST_unweighted_novarORE_PB" #Each scenario needs a unique name
scenario_group <- "TEST"
date <- as.character(Sys.time())
# Choose cost layer to apply and adjust slice accordingly.  If no costs, use "pu_3km"
cost <- cost_stack_3km[[7]]
cost_name <- names(cost)
writeLines(c("Cost layer used: ",cost_name), "costlayer.txt")
cost_value <- cellStats(cost, sum, na.rm = TRUE)
# rescale cost, when cost values too high - e.g., for actual value layers
cellStats(cost, 'max')
cost <- cost / 100
dir.create(scenario_name)
setwd(paste0("", scenario_name))
# List features and store for later tracking
feature_names <- names(feat_stack_3km)
feature_list <- as.list(feature_names)
included_features <- paste(feature_names, collapse = "; ")
# Set targets and store for later tracking file, also
#targets <- as.list(rep(0.2, length(feature_names)))
targets <- (rep(0.28, length(feature_names))) #adjust to meet overall 30% target.
targets[c(8, 26, 33, 34)] <- 0.56 #target X2 other targets for the fronts,and the salmon and eel estuaries
targets_used <- paste(targets, collapse = "; ")
#write target for each feature to text file
featurextarget <- cbind(feature_list, targets)
write.table(featurextarget, file = paste0(scenario_name,"_feature_targets.txt"), sep = ",", row.names = FALSE)
# ---------------------------------
# 3.2 Generate boundary length data for the planning units
# ---------------------------------
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
bld_3km <- boundary_matrix(pu_3km)
#bld_1km@x <- rescale(bld_1km@x, to = c(0.001,10)) # Deprecated in PrioritizR 8.0.2.7
bld_3km <-rescale_matrix(bld_3km, max = 1)  # Use for all versions after PrioritizR 8.0.2.7
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -1.5   # change this for your own data
prelim_upper <- -1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -3   # change this for your own data
prelim_upper <- 0  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_3km) %>%
add_neighbor_constraints(k=3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(prelim, file = paste0(scenario_name, "_prelim.RData"))
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -3   # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -2   # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_3km) %>%
add_neighbor_constraints(k=3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(prelim, file = paste0(scenario_name, "_prelim.RData"))
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -1  # change this for your own data
prelim_upper <- 0.5  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -0  # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- 0.5  # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- 0.75  # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- 0.6  # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_3km) %>%
add_neighbor_constraints(k=3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(prelim, file = paste0(scenario_name, "_prelim.RData"))
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
plot(pu_3km)
head(pu_3km)
pu_3km
View(pu_1km)
#pu_1km <- raster("Planning_units_1km.tif") # code for raster package
pu_1km <- rast("Planning_units_1km.tif") # code for terra package
library(terra)
library(raster)
library(sp)
library(prioritizr)
library(sf)
library(gurobi)
library(dplyr)
library(tibble)
library(scales)
library(ggplot2)
library(topsis)
library(withr)
library(purrr)
library(ggspatial)
library(terra)
library(Matrix)
#pu_1km <- raster("Planning_units_1km.tif") # code for raster package
pu_1km <- rast("Planning_units_1km.tif") # code for terra package
setwd("../PlanningUnits")
getwd()
setwd("../../PlanningUnits")
#pu_1km <- raster("Planning_units_1km.tif") # code for raster package
pu_1km <- rast("Planning_units_1km.tif") # code for terra package
# Aggregation of pu layer to 3km
pu_3km <- aggregate(pu_1km, fact=3, fun = sum)
ORE_3km <- aggregate(ORE_1km, fact =3)
# ---------------------------------
# 3.0 Set up scenario and solve
# ---------------------------------
# CHANGE TO cost_stack_3km IF WORKING 3KM SCALE
cellno <- sum(!is.na(getValues(cost_stack_3km[[1]])))
cellno
# ---------------------------------
# 3.2 Generate boundary length data for the planning units
# ---------------------------------
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
bld_3km <- boundary_matrix(pu_3km)
#bld_1km@x <- rescale(bld_1km@x, to = c(0.001,10)) # Deprecated in PrioritizR 8.0.2.7
bld_3km <-rescale_matrix(bld_3km, max = 10)  # Use for all versions after PrioritizR 8.0.2.7
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- 0.6  # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_3km) %>%
add_neighbor_constraints(k=3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(prelim, file = paste0(scenario_name, "_prelim.RData"))
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -3  # change this for your own data
prelim_upper <- 1  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_3km) %>%
add_neighbor_constraints(k=3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(prelim, file = paste0(scenario_name, "_prelim.RData"))
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
# define a new set of penalty values that ranges below the two preferred prelim values
# This time a linear scale is applied
penalty <- round(seq(prelim_penalty[6], prelim_penalty[7], length.out = 9), 5)
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
solution <- lapply(penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_1km) %>%
add_neighbor_constraints(k = 3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.1, time_limit = 1200, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
solution <- lapply(penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_3km) %>%
add_neighbor_constraints(k = 3, clamp = TRUE) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.1, time_limit = 1200, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)

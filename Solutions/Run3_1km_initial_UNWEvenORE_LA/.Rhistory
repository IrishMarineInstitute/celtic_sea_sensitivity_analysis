s <- stack(s)
names(s) <- paste0("bp_", round(x,2))
return(s)
})
# Make stacks of threatened features
threat_feat <- list()
threat_items <- c(4,12,13,14,27,30,31,32,33)
threat_feat <- features[threat_items]
threat_feat_1km <- stack(threat_feat)
names(threat_feat_1km)
feature_names <- names(feat_stack_3km)
feature_list <- as.list(feature_names)
included_features <- paste(feature_names, collapse = "; ")
png(paste0(scenario_name, "_includedfeatures.png"), width = 4000, height = 4000, res = 300)
plot(feat_stack_3km, axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
targets <- (rep(0.5, length(feature_names)))
#targets[15] <- 0.6 #CHANGES front SETTINGS
targets_used <- paste(targets, collapse = "; ")
feat_stack_3km <-aggregate(threat_feat_1km, fact=3) # aggregate feat_stack_1km in most cases
feature_names <- names(feat_stack_3km)
feature_list <- as.list(feature_names)
included_features <- paste(feature_names, collapse = "; ")
png(paste0(scenario_name, "_includedfeatures.png"), width = 4000, height = 4000, res = 300)
plot(feat_stack_3km, axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
targets <- (rep(0.5, length(feature_names)))
#targets[15] <- 0.6 #CHANGES front SETTINGS
targets_used <- paste(targets, collapse = "; ")
#write target for each feature to text file
featurextarget <- cbind(feature_list, targets)
write.table(featurextarget, file = paste0(scenario_name,"_feature_targets.txt"), sep = ",", row.names = FALSE)
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_3km) %>%
add_neighbor_constraints(k = 2) %>%
# add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,2))
return(s)
})
targets <- (rep(0.3, length(feature_names)))
#targets[15] <- 0.6 #CHANGES front SETTINGS
targets_used <- paste(targets, collapse = "; ")
#write target for each feature to text file
featurextarget <- cbind(feature_list, targets)
write.table(featurextarget, file = paste0(scenario_name,"_feature_targets.txt"), sep = ",", row.names = FALSE)
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_3km) %>%
add_neighbor_constraints(k = 2) %>%
# add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 120, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,2))
return(s)
})
# Make stacks of threatened features
threat_feat <- list()
threat_items <- c(13,14,27)
threat_feat <- features[threat_items]
threat_feat_1km <- stack(threat_feat)
names(threat_feat_1km)
feat_stack_3km <-aggregate(threat_feat_1km, fact=3) # aggregate feat_stack_1km in most cases
feature_names <- names(feat_stack_3km)
feature_list <- as.list(feature_names)
included_features <- paste(feature_names, collapse = "; ")
png(paste0(scenario_name, "_includedfeatures.png"), width = 4000, height = 4000, res = 300)
plot(feat_stack_3km, axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
targets <- (rep(0.5, length(feature_names)))
#targets[15] <- 0.6 #CHANGES front SETTINGS
targets_used <- paste(targets, collapse = "; ")
#write target for each feature to text file
featurextarget <- cbind(feature_list, targets)
write.table(featurextarget, file = paste0(scenario_name,"_feature_targets.txt"), sep = ",", row.names = FALSE)
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
length(feat_stack_3km)
# Make stacks of threatened features
threat_feat <- list()
threat_items <- c(13,14,27)
threat_feat <- features[threat_items]
threat_feat_1km <- stack(threat_feat)
names(threat_feat_1km)
feat_stack_3km <-aggregate(threat_feat_1km, fact=3) # aggregate feat_stack_1km in most cases
feature_names <- names(feat_stack_3km)
feature_list <- as.list(feature_names)
included_features <- paste(feature_names, collapse = "; ")
rm(targets)
targets <- (rep(0.5, length(feature_names)))
#targets[15] <- 0.6 #CHANGES front SETTINGS
targets_used <- paste(targets, collapse = "; ")
#write target for each feature to text file
featurextarget <- cbind(feature_list, targets)
write.table(featurextarget, file = paste0(scenario_name,"_feature_targets.txt"), sep = ",", row.names = FALSE)
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
length(feature_names)
setwd("/Users/louiselab/Documents/GitHub/mpa_ecological_sensitivity")
land <- st_read("./data/GIS_layers/IREUK_poly_ITM.shp") #in github folder GIS_layers
sa <- st_read("./data/GIS_layers/irishsea_aoi.shp") #in github folder GIS_layers
setwd("Test_Scenarios")
feature_tifs <- list.files(pattern = "\\.tif$")
features <- lapply(feature_tifs, raster)
# Set the names of the list elements to the file names
names(features) <- feature_tifs
# Create a raster stack from the list of rasters
feat_stack_1km <- stack(features)
names(feat_stack_1km)
# Make stacks of threatened features
threat_feat <- list()
threat_items <- c(13,14,27)
threat_feat <- features[threat_items]
threat_feat_1km <- stack(threat_feat)
names(threat_feat_1km)
setwd("../data/PreppedCostLayers")
cost_tifs <- list.files(pattern = "\\.tif$")
costs <- lapply(cost_tifs, raster)
# Set the names of the list elements to the file names
names(costs) <- cost_tifs
# Create a raster stack from the list of rasters
cost_stack_1km <- stack(costs)
names(cost_stack_1km)
setwd("../planning_units")
pu_3km <- raster("planning_units_3km.tif")
feat_stack_3km <-aggregate(threat_feat_1km, fact=3) # aggregate feat_stack_1km in most cases
# Aggregation method sums values across aggregated cells to maintain total costs of layer
cost_stack_3km <-aggregate(cost_stack_1km, fact=3, fun = sum)
# count cells
cellno <- sum(!is.na(getValues(cost_stack_3km[[1]])))
setwd("../")
setwd("../Solutions")
scenario_name <- "Threat_LA_AllCost_2" #Each scenario needs a unique name
scenario_group <- "Threatened Features"
date <- as.character(Sys.time())
# Choose cost layer to apply and adjust slice accordingly.  If no costs, use "pu_3km"
cost <- cost_stack_3km[[1]] # cost_stack_3km[[1]]
cost_name <- names(cost)
cost_value <- cellStats(cost, sum, na.rm = TRUE)
dir.create(scenario_name)
setwd(paste0("", scenario_name))
feature_names <- names(feat_stack_3km)
feature_list <- as.list(feature_names)
included_features <- paste(feature_names, collapse = "; ")
png(paste0(scenario_name, "_includedfeatures.png"), width = 4000, height = 4000, res = 300)
plot(feat_stack_3km, axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
targets <- (rep(0.5, length(feature_names)))
#targets[15] <- 0.6 #CHANGES front SETTINGS
targets_used <- paste(targets, collapse = "; ")
#write target for each feature to text file
featurextarget <- cbind(feature_list, targets)
write.table(featurextarget, file = paste0(scenario_name,"_feature_targets.txt"), sep = ",", row.names = FALSE)
# ---------------------------------
# 3.2 Generate boundary length data for the planning units
# ---------------------------------
bld_3km <- boundary_matrix(pu_3km)
bld_3km@x <-rescale(bld_3km@x, to = c(0.01,100))
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -3   # change this for your own data
prelim_upper <- 2  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 3)
# print penalty values
print(prelim_penalty)
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
targets <- list()
targets <- (rep(0.5, length(feature_names)))
#targets[15] <- 0.6 #CHANGES front SETTINGS
targets_used <- paste(targets, collapse = "; ")
#write target for each feature to text file
featurextarget <- cbind(feature_list, targets)
write.table(featurextarget, file = paste0(scenario_name,"_feature_targets.txt"), sep = ",", row.names = FALSE)
# ---------------------------------
# 3.2 Generate boundary length data for the planning units
# ---------------------------------
bld_3km <- boundary_matrix(pu_3km)
bld_3km@x <-rescale(bld_3km@x, to = c(0.01,100))
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -3   # change this for your own data
prelim_upper <- 2  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 3)
# print penalty values
print(prelim_penalty)
p1 <- problem(cost, feat_stack_3km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
install.packages(
file.path(
Sys.getenv("GUROBI_HOME"),
"/Library/gurobi1101/macos_universal2/R/gurobi_11.0-1_R_4.3.2.tgz"
),
repos = NULL
)
install.packages(
file.path(
Sys.getenv(/Library/gurobi1101/mac64),
install.packages(
file.path(
Sys.getenv("/Library/gurobi1101/mac64"),
"/Library/gurobi1101/macos_universal2/R/gurobi_11.0-1_R_4.3.2.tgz"
),
repos = NULL
)
install.packages(
file.path(
Sys.getenv("GUROBI_HOME"),
"/Library/gurobi1101/macos_universal2/R/gurobi_11.0-1_R_4.3.2.tgz"
),
repos = NULL
)
install.packages(
file.path(
Sys.getenv("GUROBI_HOME"),
/Library/gurobi1101/macos_universal2/R/gurobi_11.0-1_R_4.3.2.tgz
install.packages(
file.path(
Sys.getenv("GUROBI_HOME"),
"/Library/gurobi1101/macos_universal2/R/gurobi_11.0-1_R_4.3.2.tgz"
),
repos = NULL
)
install.packages("slam", repos = "https://cloud.r-project.org")
library(gurobi)
# create optimization problem
model <- list()
model$obj        <- c(1, 1, 2)
model$modelsense <- "max"
model$rhs        <- c(4, 1)
model$sense      <- c("<", ">")
model$vtype      <- "B"
model$A          <- matrix(c(1, 2, 3, 1, 1, 0), nrow = 2, ncol = 3,
byrow = TRUE)
# solve the optimization problem using Gurobi
result <- gurobi(model, list())
library(prioritizr)
# load data
sim_pu_raster <- get_sim_pu_raster()
add_gurobi_solver()
add_gurobi_solver(.)
add_gurobi_solver()
sim_pu_raster <- get_sim_pu_raster()
View(model)
View(result)
View(model)
update.packages()
View(model)
# Libraries
library(raster)
library(sp)
# Libraries
library(raster)
library(sp)
library(prioritizr)
library(sf)
library(gurobi)
library(dplyr)
library(tibble)
library(scales)
library(ggplot2)
library(topsis)
library(withr)
library(purrr)
# Libraries
library(raster)
install.packages("raster")
# Libraries
library(raster)
library(prioritizr)
library(sp)
library(prioritizr)
library(sf)
library(gurobi)
library(dplyr)
library(tibble)
library(scales)
library(ggplot2)
library(topsis)
library(withr)
library(purrr)
library(ggspatial)
library(terra)
library(Matrix)
g
# setwd("H:/mpa_ecological_sensitivity2/mpa_ecological_sensitivity/Celtic Sea/ProcessedFeatures/FinalFeatures")
setwd("/Users/louiselab/Documents/GitHub/mpa_ecological_sensitivity/Celtic Sea/ProcessedFeatures/FinalFeatures")
feature_tifs <- list.files(pattern = "\\.tif$")
features <- lapply(feature_tifs, raster)  # code for raster package
names(features) <- feature_tifs
feat_stack_1km <- stack(features)  # code for raster package
names(feat_stack_1km)
front_layer <- grep("Fronts_temp_1km.tif", names(feat_stack_1km))
feat_stack_1km <- dropLayer(feat_stack_1km, unlist(front_layer)) # note to drop from rasterstack use dropLayer(stack_name, unlist(index_variable))
names(feat_stack_1km)
setwd("/Users/Louise/Documents/GitHub/mpa_ecological_sensitivity/Celtic Sea/ProcessedFeatures/CelticSeaFront/split")
CelticSeaFront <- raster("CelticSeaFront.tif")
setwd("Users/louiselab/Documents/GitHub/mpa_ecological_sensitivity/Celtic Sea/ProcessedFeatures/CelticSeaFront/split")
getwd()
setwd("/Users/louiselab/Documents/GitHub/mpa_ecological_sensitivity/Celtic Sea/ProcessedFeatures/CelticSeaFront/split")
CelticSeaFront <- raster("CelticSeaFront.tif")
CoastalFront <- raster("coastal_front.tif")
feat_stack_1km <- stack(feat_stack_1km, CelticSeaFront, CoastalFront)
names(feat_stack_1km)
#setwd("../../ProcessedCostLayers") # USE IF 1.2 SKIPPED
setwd("../../../ProcessedCostLayers")
cost_tifs <- list.files(pattern = "\\.tif$")
costs <- lapply(cost_tifs, raster) # code for raster package
# costs <- lapply(cost_tifs, rast)  # code for terra package
names(costs) <- cost_tifs
cost_stack_1km <- stack(costs)  # code for raster package
# cost_stack_1km <- c(costs)  # code for terra package
names(cost_stack_1km)
setwd("../PlanningUnits")
pu_1km <- raster("Planning_units_1km.tif") # code for raster package
setwd("../ProcessedCostLayers/IntermediateLayers")
ORE_1km <- raster("ORE_even_1km.tif")
# ---------------------------------
# 3.0 Set up scenario and solve
# ---------------------------------
# CHANGE TO cost_stack_3km IF WORKING 3KM SCALE
cellno <- sum(!is.na(getValues(cost_stack_1km[[2]])))
setwd("Solutions")
scenario_name <- "1km_initial_UNWEvenORE_LA" #Each scenario needs a unique name
scenario_group <- "COSTS"
date <- as.character(Sys.time())
# Choose cost layer to apply and adjust slice accordingly.  If no costs, use "pu_3km"
names(cost_stack_1km)
cost <- cost_stack_1km[[4]] # Choose cost layer
cost_name <- names(cost)
# rescale cost, when cost values too high - e.g., for actual value layers
cellStats(cost, 'max')
cost <- cost / 100
dir.create(scenario_name)
setwd(paste0("", scenario_name))
getwd()
setwd("/Users/louiselab/Documents/GitHub/mpa_ecological_sensitivity/Celtic Sea/Solutions/1km_initial_UNWEvenORE_LA")
writeLines(c("Cost layer used: ",cost_name), "costlayer.txt")
cost_value <- cellStats(cost, sum, na.rm = TRUE)
# List features and store for later tracking
feature_names <- names(feat_stack_1km)
feature_list <- as.list(feature_names)
included_features <- paste(feature_names, collapse = "; ")
# INITIAL RUN TARGETS
targets <- (rep(0.28, length(feature_names))) #adjust to meet overall 30% target.
targets[c(8, 26, 33, 34)] <- 0.56 #target X2 other targets for the fronts,and the salmon and eel estuaries
targets_used <- paste(targets, collapse = "; ")
#write target for each feature to text file
featurextarget <- cbind(feature_list, targets)
write.table(featurextarget, file = paste0(scenario_name,"_feature_targets.txt"), sep = ",", row.names = FALSE)
targets_used <- paste(targets, collapse = "; ")
# ---------------------------------
# 3.2 Generate boundary length data for the planning units
# ---------------------------------
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
bld_1km <- boundary_matrix(pu_1km)
# bld_3km@x <-rescale(bld_3km@x, to = c(0.001,10)) # Deprecated in PrioritizR 8.0.2.7
bld_1km <-rescale_matrix(bld_1km, max = 10)  # Use for all versions after PrioritizR 8.0.2.7
# ---------------------------------
# 3.3 Define a range of penalty values
# ---------------------------------
prelim_lower <- -3   # change this for your own data
prelim_upper <- 0  # change this for your own data
prelim_penalty <- round(10^seq(prelim_lower, prelim_upper, length.out = 9), 5)
# print penalty values
print(prelim_penalty)
# CHANGE TO FEAT_STACK_3KM IF WORKING 3KM SCALE
p1 <- problem(cost, feat_stack_1km) %>%
add_min_set_objective() %>%  # minimize the cost of the solution whilst ensuring that all targets are met
add_relative_targets(targets) %>%
add_binary_decisions()
save(p1, file = paste0(scenario_name, "_problem.RData"))
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
prelim <- lapply(prelim_penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_1km) %>%
add_neighbor_constraints(k=2) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 180, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.2, time_limit = 600, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
save(prelim, file = paste0(scenario_name, "_prelim.RData"))
png(paste0(scenario_name, "_prelims.png"), width = 1200, height = 1200, res = 300)
plot(stack(prelim), axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
# define a new set of penalty values that ranges below the two preferred prelim values
# This time a linear scale is applied
penalty <- round(seq(prelim_penalty[4], prelim_penalty[6], length.out = 9), 5)
# define a new set of penalty values that ranges below the two preferred prelim values
# This time a linear scale is applied
penalty <- round(seq(prelim_penalty[4], prelim_penalty[6], length.out = 9), 5)
# CHANGE TO BLD_3KM IF WORKING 3KM SCALE
solution <- lapply(penalty, function(x) {
s <-
p1 %>%
add_boundary_penalties(penalty = x, data = bld_1km) %>%
add_neighbor_constraints(k = 2) %>%
#add_cbc_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.1, time_limit = 1200, verbose = TRUE) %>%
add_gurobi_solver(threads = parallel::detectCores(TRUE) - 1, gap = 0.05, time_limit = 3600, verbose = TRUE) %>%
solve()
s <- stack(s)
names(s) <- paste0("bp_", round(x,5))
return(s)
})
View(cost_stack_1km)
save(solution, file = paste0(scenario_name, "_solution.RData"))
solutions <-stack(solution)
#double check working directory
png(paste0(scenario_name, "_solutions.png"), width = 1200, height = 1200, res = 300)
plot(solutions, axes = FALSE, box = FALSE, legend = FALSE)
dev.off()
for (i in 1:nlayers(solutions)) {
# Write files
soln <- solutions[[i]]
writeRaster(soln, paste0(scenario_name, "_bp_", penalty[[i]], ".tif"), format = "GTiff", overwrite = TRUE)}
# Evaluate feature representation in the list of raster solutions
featurereps <- lapply(solution, function(x) {
eval_feature_representation_summary(p1, x)
})
# Name the tibbles in the list according to the penalty applied
names(featurereps) <- paste0(scenario_name, "_bp_", penalty)
# Examine them in the console
print(featurereps)
# stack the fifth column of all tibbles and bind the data
feat_df <- featurereps %>%
map_dfc(~select(.x, relative_held)) %>%
set_names(nm = names(featurereps)) %>%
mutate(feature = c(featurereps[[1]][[2]]))
library(dplyr)
# stack the fifth column of all tibbles and bind the data
feat_df <- featurereps %>%
map_dfc(~select(.x, relative_held)) %>%
set_names(nm = names(featurereps)) %>%
mutate(feature = c(featurereps[[1]][[2]]))
# Examine them in the console
print(featurereps)
# stack the fifth column of all tibbles and bind the data
feat_df <- featurereps %>%
map_dfc(~select(.x, relative_held)) %>%
set_names(nm = names(featurereps)) %>%
mutate(feature = c(featurereps[[1]][[2]]))
rlang::last_trace()
# stack the fifth column of all tibbles and bind the data
feat_df <- featurereps %>%
map_dfc(~select(.x, relative_held)) %>%
set_names(nm = names(featurereps)) %>%
mutate(feature = c(featurereps[[1]][[2]]))
getwd()
library(dplyr)
library(tibble)
View(solutions)
for (i in 1:nlayers(solutions)) {
# Write files
soln <- solutions[[i]]
writeRaster(soln, paste0(scenario_name, "_bp_", penalty[[i]], ".tif"), format = "GTiff", overwrite = TRUE)}
# Evaluate feature representation in the list of raster solutions
featurereps <- lapply(solution, function(x) {
eval_feature_representation_summary(p1, x)
})
# Name the tibbles in the list according to the penalty applied
names(featurereps) <- paste0(scenario_name, "_bp_", penalty)
# Examine them in the console
print(featurereps)
# stack the fifth column of all tibbles and bind the data
feat_df <- featurereps %>%
map_dfc(~select(.x, relative_held)) %>%
set_names(nm = names(featurereps)) %>%
mutate(feature = c(featurereps[[1]][[2]]))
sessionInfo()
install.packages("installr")
library(installr)
updateR()
install.packages(‘installr’)
library(installr)
updateR()
check.for.updates.R()
install.packages("devtools")
updateR(admin_password = "PASSWORD") # Where "PASSWORD" stands for your system password
